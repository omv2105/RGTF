<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
  <title>ReGrow the Forest</title>
  <style>

* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

    * {
      user-select: none;
    }

    body {
  margin: 0;
  background-color: #548554;
  font-family: Arial, sans-serif;
  color: #ecebdeea;
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 100vh;
  overflow: hidden;
  cursor: none; /* Hide default cursor */
}

.screen {
  display: none;
  text-align: center;
  width: 100%;
  height: 100%;
  padding: 20px;
  overflow-y: auto;
}

.screen.active {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
}

    .random-image {
      position: absolute;
      transition: transform 0.2s ease-out;
    }

    .wave span {
      display: inline-block;
      font-size:  min(4em, 10vw);
      font-weight: bold;
      vertical-align: middle;
      transition: transform 0.2s;
    }

    .asset {
      height: 4em;
      width: auto;
      object-fit: contain;
      transition: transform 0.2s;
    }

    .title-container {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 20px;
    }

    .content {
      max-width: 800px;
      padding: 20px;
    }

    p {
      font-size:  min(1.2em, 5vw);;
    }

    h1 {
      font-size:  min(4em, 10vw);;
      font-weight: bold;
      cursor: pointer;
    }

    #customCursor {
      position: absolute;
      width: 40px;
      height: 40px;
      pointer-events: none;
      z-index: 9999;
      display: none;
    }

    .smoke {
      position: absolute;
      width: 20px;
      height: 20px;
      background: rgba(200, 200, 200, 0.548);
      border-radius: 50%;
      pointer-events: none;
      z-index: 200;
      filter: blur(2px);
      transition: transform 1s ease-out, opacity 1s ease-out;
    }
    
    /* Popup styles */
    .popup-container {
      position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: #548554;
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
  opacity: 0;
  visibility: hidden;
  transition: opacity 0.3s, visibility 0.3s;
}
    
    .popup-container.active {
      opacity: 1;
      visibility: visible;
    }
    
    .popup {
      background-color: #3a3d2c;
  border-radius: 10px;
  padding: 30px;
  max-width: min(600px, 90vw); /* Responsive max width */
  width: 90%;
  box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
  position: relative;
  overflow-y: auto;
  max-height: 80vh; /* Allow scrolling on small screens */
}
    
    .popup h2 {
      margin-top: 0;
  color: #D9D3BD;
  font-size: min(2em, 8vw); /* Responsive font size */
}
    
    .start-game-btn {
      background-color: #80836a;
      color: #D9D3BD;
      border: none;
      padding: 12px 24px;
      font-size:  min(1.2em, 5vw);;
      border-radius: 5px;
      cursor: none;
      margin-top: 20px;
      transition: background-color 0.2s;
    }
    
    .start-game-btn:hover {
      background-color: #a18e71;
    }

    /* Game styles */
    #gameContainer {
  position: relative;
  width: min(800px, 95vw); /* Use either 800px or 95% of viewport width, whichever is smaller */
  height: min(600px, 70vh); /* Use either 600px or 70% of viewport height, whichever is smaller */
  overflow: hidden;
  background-color: #3a6a3a;
  border-radius: 10px;
  box-shadow: 0 5px 15px #606060;
}

#forestCanvas {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
}

.game-ui {
  position: absolute;
  bottom: 20px;
  left: 0;
  width: 100%;
  display: flex;
  justify-content: center;
  gap: min(20px, 3vw); /* Responsive gap */
  z-index: 100;
  flex-wrap: wrap; /* Allow wrapping on small screens */
  padding: 0 10px;
}

.ui-panel {
  background-color: rgba(0, 0, 0, 0.5);
  padding: min(10px, 2vw) min(20px, 4vw); /* Responsive padding */
  border-radius: 20px;
  display: flex;
  align-items: center;
  gap: 10px;
  margin-bottom: 5px;
}

.ui-icon {
  width: min(30px, 6vw); /* Responsive width */
  height: min(30px, 6vw); /* Responsive height */
  background-color: #D9D3BD;
  border-radius: 50%;
  flex-shrink: 0;
}

.ui-panel div:last-child {
  width: min(150px, 30vw); /* Responsive width */
}

.progress-container {
  width: 100%;
  background-color: rgba(255, 255, 255, 0.2);
  border-radius: 10px;
  overflow: hidden;
  height: min(15px, 3vw); /* Responsive height */
}

    .progress-bar {
      height: 100%;
      border-radius: 10px;
      transition: width 0.3s;
    }

    #forestHealth {
      background-color: #bec49f;
    }

    #fireControl {
      background-color: #a78988;
    }

    #biodiversity {
      background-color: #b6697c;
    }

    .forest-element {
      position: absolute;
      background-size: contain;
      background-repeat: no-repeat;
      background-position: center bottom;
      transition: transform 0.3s, opacity 0.5s;
    }

    .tree {
      width: 40px;
      height: 60px;
      background-image: url('tree20.png');
      z-index: 10;
    }

    .overgrowth {
      width: 60px;
      height: 30px;
      background-image: url('placeholder-overgrowth.png');
      z-index: 5;
    }

    .wildlife {
      width: 30px;
      height: 30px;
      background-image: url('placeholder-wildlife.png');
      z-index: 15;
    }

    .sapling {
      width: 20px;
      height: 30px;
      background-image: url('placeholder-sapling.png');
      z-index: 8;
      opacity: 0;
    }

    .fire {
      width: 40px;
      height: 50px;
      background-image: url('placeholder-fire.png');
      z-index: 20;
      opacity: 0;
      pointer-events: none;
    }

    .burned {
      width: 40px;
      height: 30px;
      background-image: url('placeholder-burned.png');
      z-index: 7;
      opacity: 0;
    }

    .level-complete {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: rgba(0, 0, 0, 0.8);
      padding: 30px;
      border-radius: 10px;
      text-align: center;
      z-index: 1000;
      display: none;
    }

    .level-complete h2 {
      color: #D9D3BD;
      margin-top: 0;
    }

    .level-complete p {
      color: #D9D3BD;
    }

    .level-btn {
      background-color: #86775f;
      color: #D9D3BD;
      border: none;
      padding: 10px 20px;
      font-size:  min(1em, 3.5vw);;
      border-radius: 5px;
      margin-top: 20px;
      cursor: none;
    }

    .stats-row {
      display: flex;
      justify-content: space-between;
      margin: 10px 0;
    }

    .stat-label {
      text-align: left;
    }

    .stat-value {
      text-align: right;
    }
    
    #levelIndicator {
      position: absolute;
      top: 20px;
      left: 20px;
      background-color: rgba(0, 0, 0, 0.5);
      padding: 10px 15px;
      border-radius: 20px;
      font-size:  min(1.2em, 5vw);;
      z-index: 100;
    }
    
    .fire-particle {
      position: absolute;
      width: 8px;
      height: 8px;
      background-color: orange;
      border-radius: 50%;
      filter: blur(2px);
      z-index: 25;
      pointer-events: none;
    }

    /* New stressful elements */
    #timerBar {
      position: absolute;
      top: 20px;
      right: 20px;
      width: 200px;
      height: 20px;
      background-color: rgba(0, 0, 0, 0.5);
      border-radius: 10px;
      overflow: hidden;
      z-index: 100;
    }

    #timerFill {
      height: 100%;
      background-color: #F44336;
      width: 100%;
      transition: width 0.1s linear;
    }

    .emergency-warning {
      position: absolute;
      top: 60px;
      left: 0;
      width: 100%;
      text-align: center;
      color: #88504c;
      font-size:  min(1.5em, 5vw);;
      font-weight: bold;
      text-shadow: 0 0 5px #000;
      animation: blink 0.5s infinite;
      display: none;
      z-index: 100;
    }

    @keyframes blink {
      0% { opacity: 1; }
      50% { opacity: 0.3; }
      100% { opacity: 1; }
    }

    .wind-indicator {
      position: absolute;
      top: 60px;
      right: 20px;
      background-color: rgba(0, 0, 0, 0.5);
      padding: 8px 15px;
      border-radius: 20px;
      font-size:  min(1em, 3vw);;
      z-index: 100;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .wind-arrow {
      width: 20px;
      height: 20px;
      transform-origin: center;
      transition: transform 1s ease;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    
    .weather-effect {
      position: absolute;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 90;
      opacity: 0;
      transition: opacity 2s;
    }
    
    .rain-effect {
      background: linear-gradient(to bottom, rgba(0,0,0,0) 0%, rgba(105,155,255,0.2) 100%);
    }
    
    .drought-effect {
      background: radial-gradient(circle, rgba(255,156,0,0.2) 0%, rgba(255,123,0,0.1) 100%);
    }

    .lightning-flash {
      position: absolute;
      width: 100%;
      height: 100%;
      background-color: rgba(255, 255, 255, 0.8);
      z-index: 95;
      pointer-events: none;
      opacity: 0;
    }
    
    .screen-shake {
      animation: shake 0.5s linear;
    }
    
    @keyframes shake {
      0% { transform: translate(0, 0) }
      10% { transform: translate(-5px, -5px) }
      20% { transform: translate(5px, 5px) }
      30% { transform: translate(-5px, 5px) }
      40% { transform: translate(5px, -5px) }
      50% { transform: translate(-5px, 0px) }
      60% { transform: translate(5px, 5px) }
      70% { transform: translate(-5px, -5px) }
      80% { transform: translate(5px, 0px) }
      90% { transform: translate(-5px, 5px) }
      100% { transform: translate(0, 0) }
    }

    .animal-warning {
      position: absolute;
      color: #FFD700;
      font-weight: bold;
      font-size: 14px;
      z-index: 110;
      text-shadow: 0 0 3px #000;
      pointer-events: none;
    }
    
    .news-alert {
      position: absolute;
      bottom: 80px;
      left: 20px;
      right: 20px;
      background-color: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 10px;
      border-radius: 5px;
      font-size:  min(0.9em, 3.5vw);;
      z-index: 150;
      transform: translateY(100px);
      opacity: 0;
      transition: transform 0.3s, opacity 0.3s;
    }
    
    .news-alert.show {
      transform: translateY(0);
      opacity: 1;
    }

    #app {
  width: 100%;
  height: 100vh;
  max-width: 1200px;
  display: flex;
  justify-content: center;
  align-items: center;
  position: relative;
}
  </style>
</head>

<body>
  <div id="app">
    <!-- Splash Screen -->
    <div class="screen active" id="splashScreen">
      <div class="content">
        <div class="title-container" id="titleContainer">
          <img src="asset 1.png" class="asset" id="asset1">
          <div id="title" class="wave"></div>
          <img src="asset 2.png" class="asset" id="asset2">
        </div>
      </div>
    </div>

    <!-- New Welcome Screen -->
    <div class="screen" id="newScreen">
      <div class="content">
        <div id="newTitle" class="wave"></div>
        <p>Happy to have you with with us.<br>Let's learn about how your actions can impact the forest.<br>For future reference, just press anywhere to continue.</p>
      </div>
    </div>

    <!-- Instructions Screen -->
    <div class="screen" id="instructionsScreen">
      <div class="content">
        <div id="instructionsTitle" class="wave"></div>
        <p>
          Every year, wildfires globally burn hundreds of thousands, if not millions, of acres of forest. 
          These fires cause significant damage to ecosystems, infrastructure, and can be deadly, especially when they spread 
          rapidly due to factors like dry conditions and strong winds. 
        </p>
        <p>
          Although it might sound counterproductive, controlled burns are actually the safest way to manage overgrowth 
          and promote new biodiversity in forests.   
        </p>
      </div>
    </div>

    <!-- Game Screen -->
    <div class="screen" id="gameScreen">
      <div class="content">
        <div id="gameContainer">
          <canvas id="forestCanvas" width="800" height="600"></canvas>
          <div id="levelIndicator">Level 1</div>
          
          <!-- Timer Bar (new) -->
          <div id="timerBar">
            <div id="timerFill"></div>
          </div>
          
          <!-- Wind Indicator (new) -->
          <div class="wind-indicator">
            Wind: <span id="windSpeed">None</span>
            <div class="wind-arrow">→</div>
          </div>
          
          <!-- Emergency Warning (new) -->
          <div class="emergency-warning" id="emergencyWarning">CRITICAL FIRE RISK!</div>
          
          <!-- Weather Effects (new) -->
          <div class="weather-effect rain-effect" id="rainEffect"></div>
          <div class="weather-effect drought-effect" id="droughtEffect"></div>
          <div class="lightning-flash" id="lightningFlash"></div>
          
          <!-- News Alert (new) -->
          <div class="news-alert" id="newsAlert"></div>
          
          <div class="game-ui">
            <div class="ui-panel">
              <div class="ui-icon" style="background-image: url('placeholder-health.png')"></div>
              <div style="width: 150px;">
                <div>Forest Health</div>
                <div class="progress-container">
                  <div id="forestHealth" class="progress-bar" style="width: 100%;"></div>
                </div>
              </div>
            </div>
            
            <div class="ui-panel">
              <div class="ui-icon" style="background-image: url('placeholder-fire.png')"></div>
              <div style="width: 150px;">
                <div>Fire Control</div>
                <div class="progress-container">
                  <div id="fireControl" class="progress-bar" style="width: 100%;"></div>
                </div>
              </div>
            </div>
            
            <div class="ui-panel">
              <div class="ui-icon" style="background-image: url('placeholder-biodiversity.png')"></div>
              <div style="width: 150px;">
                <div>Biodiversity</div>
                <div class="progress-container">
                  <div id="biodiversity" class="progress-bar" style="width: 50%;"></div>
                </div>
              </div>
            </div>
          </div>
          
          <div class="level-complete" id="levelComplete">
            <h2>Level Complete!</h2>
            <p>You've successfully maintained the forest's health!</p>
            
            <div class="stats-row">
              <div class="stat-label">Trees Saved:</div>
              <div class="stat-value" id="treesSaved">0</div>
            </div>
            
            <div class="stats-row">
              <div class="stat-label">New Growth:</div>
              <div class="stat-value" id="newGrowth">0</div>
            </div>
            
            <div class="stats-row">
              <div class="stat-label">Wildlife Protected:</div>
              <div class="stat-value" id="wildlifeProtected">0</div>
            </div>
            
            <button class="level-btn" id="nextLevelBtn">Next Level</button>
          </div>
        </div>
      </div>
    </div>
    
    <!-- Game Instructions Popup -->
    <div class="popup-container" id="gameInstructionsPopup">
      <div class="popup">
        <h2>How to Play</h2>
        <p>Use your cursor (shown as a fire icon) to create controlled burns:</p>
        <ul style="text-align: left; margin: 20px 0;">
          <li>Click and drag to create controlled burn areas</li>
          <li>Clear overgrown areas to allow new growth</li>
          <li>Be careful not to burn too much at once</li>
          <li>Watch for wildlife and protect their habitats</li>
          <li><strong>New:</strong> Watch for changing weather conditions that affect fire spread</li>
          <li><strong>New:</strong> Complete objectives before time runs out</li>
          <li><strong>New:</strong> React to emergency events that can threaten the forest</li>
        </ul>
        <p>Your goal is to maintain a healthy, balanced forest ecosystem through careful management.</p>
        <button class="start-game-btn" id="startGameBtn">Start Forest Management</button>
      </div>
    </div>
  </div>

  <img src="asset 7.png" id="customCursor" style="display: none;" />

  <script>
    document.addEventListener("DOMContentLoaded", function () {
      const splashScreen = document.getElementById("splashScreen");
      const newScreen = document.getElementById("newScreen");
      const instructionsScreen = document.getElementById("instructionsScreen");
      const gameScreen = document.getElementById("gameScreen");
      const gameInstructionsPopup = document.getElementById("gameInstructionsPopup");
      const levelComplete = document.getElementById("levelComplete");
      const nextLevelBtn = document.getElementById("nextLevelBtn");
      
      const forestCanvas = document.getElementById("forestCanvas");
      const ctx = forestCanvas.getContext("2d");
      
      const title = document.getElementById("title");
      const newTitle = document.getElementById("newTitle");
      const instructionsTitle = document.getElementById("instructionsTitle");

      const asset1 = document.getElementById("asset1");
      const asset2 = document.getElementById("asset2");

      const customCursor = document.getElementById("customCursor");
      
      // New UI elements
      const timerFill = document.getElementById("timerFill");
      const emergencyWarning = document.getElementById("emergencyWarning");
      const windSpeedEl = document.getElementById("windSpeed");
      const windArrow = document.querySelector(".wind-arrow");
      const rainEffect = document.getElementById("rainEffect");
      const droughtEffect = document.getElementById("droughtEffect");
      const lightningFlash = document.getElementById("lightningFlash");
      const newsAlert = document.getElementById("newsAlert");

      // Game state
      let currentLevel = 1;
      let forestHealth = 100;
      let fireControl = 100;
      let biodiversity = 50;
      let treeCount = 0;
      let saplingCount = 0;
      let wildlifeCount = 0;
      
      // Timer variables
      let levelTimeLimit = 60; // seconds
      let levelTimeRemaining = levelTimeLimit;
      let lastTimerUpdate = 0;
      
      // Wind system
      let windDirection = 0; // in radians, 0 = right, PI/2 = down
      let windSpeed = 0; // 0-10 scale
      let windChangeTimer = 0;
      
      // Weather system
      let weatherType = "normal"; // normal, rain, drought
      let weatherIntensity = 0; // 0-10 scale
      let weatherTimer = 0;
      let weatherChangeChance = 0.002; // chance per frame to change weather
      
      // Emergency events
      let emergencyActive = false;
      let emergencyType = null;
      let emergencyTimer = 0;
      let emergencyChance = 0.0005; // chance per frame for emergency event
      
      // News system
      let newsTimer = 0;
      const newsMessages = [
        "BREAKING: Nearby county reports record drought conditions.",
        "ALERT: Wind speeds expected to increase in the next few hours.",
        "WARNING: Lightning storms reported in neighboring regions.",
        "UPDATE: Biodiversity decline affecting multiple forest ecosystems.",
        "REPORT: Climate change increasing wildfire frequency by 25%.",
        "URGENT: Protect wildlife habitats during controlled burns."
      ];
      
      // Game elements
      let trees = [];
      let overgrowth = [];
      let wildlife = [];
      let saplings = [];
      let fires = [];
      let burnedAreas = [];
      
      // Stats for level completion
      let treesSaved = 0;
      let newGrowth = 0;
      let wildlifeProtected = 0;
      
      // Cursor variables
      let isDrawing = false;
      let lastSmokeTime = 0;
      
      // Animation frame ID
      let animationFrameId;

      // Title wave animation setup
      const titleText = "ReGrow the Forest";
      titleText.split("").forEach((char, index) => {
        const span = document.createElement("span");
        span.textContent = char === " " ? "\u00A0" : char;
        span.style.setProperty("--i", index);
        title.appendChild(span);
      });

      const newTitleText = "Hi there!";
      newTitleText.split("").forEach((char, index) => {
        const span = document.createElement("span");
        span.textContent = char === " " ? "\u00A0" : char;
        span.style.setProperty("--i", index);
        newTitle.appendChild(span);
      });

      const instructionsText = "Forest Care Instructions";
      instructionsText.split("").forEach((char, index) => {
        const span = document.createElement("span");
        span.textContent = char === " " ? "\u00A0" : char;
        span.style.setProperty("--i", index);
        instructionsTitle.appendChild(span);
      });

      // Wave animation
      let waveStep = 0;
      setInterval(() => {
        const titleSpans = title.querySelectorAll("span");
        const newTitleSpans = newTitle.querySelectorAll("span");
        const instructionsSpans = instructionsTitle.querySelectorAll("span");

        [titleSpans, newTitleSpans, instructionsSpans].forEach(spans => {
          spans.forEach((span, index) => {
            const wave = Math.sin(waveStep + index * 0.4) * 10;
            span.style.transform = `translateY(${wave}px)`;
          });
        });

        const imgWave = Math.sin(waveStep) * 10;
        asset1.style.transform = `translateY(${imgWave}px)`;
        asset2.style.transform = `translateY(${imgWave}px)`;

        waveStep += 0.1;
      }, 30);

      // Navigation clicks
      document.getElementById("titleContainer").addEventListener("click", () => {
        splashScreen.classList.remove("active");
        newScreen.classList.add("active");
      });

      document.getElementById("newScreen").addEventListener("click", () => {
        newScreen.classList.remove("active");
        instructionsScreen.classList.add("active");
      });

      instructionsTitle.addEventListener("click", () => {
        instructionsScreen.classList.remove("active");
        gameInstructionsPopup.classList.add("active");
      });
      
      document.getElementById("startGameBtn").addEventListener("click", () => {
        gameInstructionsPopup.classList.remove("active");
        gameScreen.classList.add("active");
        startGame();
      });
      
      nextLevelBtn.addEventListener("click", () => {
        levelComplete.style.display = "none";
        currentLevel++;
        document.getElementById("levelIndicator").textContent = `Level ${currentLevel}`;
        resetLevel();
        startLevel();
      });

      // Show news alert
      function showNewsAlert(message) {
        newsAlert.textContent = message;
        newsAlert.classList.add("show");
        
        setTimeout(() => {
          newsAlert.classList.remove("show");
        }, 5000);
      }
      
      // Update weather conditions
      function updateWeather() {
        weatherTimer++;
        
        // Check for weather change
        if (Math.random() < weatherChangeChance && weatherTimer > 300) {
          const previousWeather = weatherType;
          
          // Choose new weather
          const weatherOptions = ["normal", "rain", "drought"];
          weatherType = weatherOptions[Math.floor(Math.random() * weatherOptions.length)];
          
          // Don't pick the same weather twice
          if (weatherType === previousWeather) {
            weatherType = weatherOptions[(weatherOptions.indexOf(weatherType) + 1) % weatherOptions.length];
          }
          
          // Set intensity
          weatherIntensity = Math.random() * 5 + 5; // 5-10 scale for stronger effect
          weatherTimer = 0;
          
          // Apply weather effects
          if (weatherType === "rain") {
            rainEffect.style.opacity = weatherIntensity / 10;
            droughtEffect.style.opacity = 0;
            fireControl += weatherIntensity; // Rain helps with fire control
            if (fireControl > 100) fireControl = 100;
            showNewsAlert("Weather changing: Rain is helping control fires but reducing visibility.");
          } else if (weatherType === "drought") {
            rainEffect.style.opacity = 0;
            droughtEffect.style.opacity = weatherIntensity / 10;
            fireControl -= weatherIntensity; // Drought hurts fire control
            if (fireControl < 0) fireControl = 0;
            showNewsAlert("Weather alert: Drought conditions increasing fire danger significantly.");
          } else {
            rainEffect.style.opacity = 0;
            droughtEffect.style.opacity = 0;
            showNewsAlert("Weather update: Conditions returning to normal.");
          }
          
          updateUI();
        }
        
        // Chance for lightning strike during rain
        if (weatherType === "rain" && Math.random() < 0.001 * weatherIntensity) {
          createLightningStrike();
        }
        
        // Weather effects fade over time
        if (weatherType === "normal") {
          if (parseFloat(rainEffect.style.opacity) > 0) {
            rainEffect.style.opacity = Math.max(0, parseFloat(rainEffect.style.opacity) - 0.01);
          }
          if (parseFloat(droughtEffect.style.opacity) > 0) {
            droughtEffect.style.opacity = Math.max(0, parseFloat(droughtEffect.style.opacity) - 0.01);
          }
        }
      }
      
      // Create lightning strike
      function createLightningStrike() {
        // Visual effect
        lightningFlash.style.opacity = 0.8;
        setTimeout(() => {
          lightningFlash.style.opacity = 0;
        }, 100);
        
        // Screen shake
        gameContainer.classList.add("screen-shake");
        setTimeout(() => {
          gameContainer.classList.remove("screen-shake");
        }, 500);
        
        // Create fire at random location
        const x = Math.random() * forestCanvas.width;
        const y = Math.random() * forestCanvas.height;
        
        createFire(x, y, 2); // More intense fire from lightning
        
        showNewsAlert("⚡ LIGHTNING STRIKE! New fire has started!");
      }
      
      // Update wind conditions
      function updateWind() {
        windChangeTimer++;
        
        // Change wind periodically
        if (windChangeTimer > 300) {
          if (Math.random() < 0.05) {
            // Dramatic wind change
            const previousSpeed = windSpeed;
            windSpeed = Math.floor(Math.random() * 10) + 1;
            windDirection = Math.random() * Math.PI * 2;
            
            // Update UI
            windSpeedEl.textContent = getWindSpeedText(windSpeed);
            windArrow.style.transform = `rotate(${windDirection}rad)`;
            
            // Notify if significant change
            if (Math.abs(windSpeed - previousSpeed) > 3 && windSpeed > 5) {
              showNewsAlert(`Wind alert: Strong ${getWindSpeedText(windSpeed).toLowerCase()} winds affecting fire spread!`);
            }
            
            windChangeTimer = 0;
          } else {
            // Subtle wind change
            windSpeed += (Math.random() - 0.5) * 2;
            if (windSpeed < 0) windSpeed = 0;
            if (windSpeed > 10) windSpeed = 10;
            
            windDirection += (Math.random() - 0.5) * 0.5;
            
            // Update UI
            windSpeedEl.textContent = getWindSpeedText(windSpeed);
            windArrow.style.transform = `rotate(${windDirection}rad)`;
          }
        }
      }
      
      // Get text description of wind speed
      function getWindSpeedText(speed) {
        if (speed < 1) return "None";
        if (speed < 3) return "Light";
        if (speed < 6) return "Moderate";
        if (speed < 8) return "Strong";
        return "Severe";
      }
      
      // Update emergency situations
      function updateEmergencies() {
        // Check for new emergency
        if (!emergencyActive && Math.random() < emergencyChance * currentLevel) {
          // Start emergency
          emergencyActive = true;
          emergencyTimer = 600; // 10 seconds at 60fps
          
          // Choose emergency type
          const emergencyTypes = ["wildfire", "drought", "infestation", "storm"];
          emergencyType = emergencyTypes[Math.floor(Math.random() * emergencyTypes.length)];
          
          // Apply emergency effects
          if (emergencyType === "wildfire") {
            emergencyWarning.textContent = "WILDFIRE APPROACHING!";
            emergencyWarning.style.display = "block";
            // Create several fires at edge of map
            const edgeSide = Math.floor(Math.random() * 4);
            for (let i = 0; i < 5; i++) {
              let x, y;
              if (edgeSide === 0) { // Top
                x = Math.random() * forestCanvas.width;
                y = 20;
              } else if (edgeSide === 1) { // Right
                x = forestCanvas.width - 20;
                y = Math.random() * forestCanvas.height;
              } else if (edgeSide === 2) { // Bottom
                x = Math.random() * forestCanvas.width;
                y = forestCanvas.height - 20;
              } else { // Left
                x = 20;
                y = Math.random() * forestCanvas.height;
              }
              createFire(x, y, 3); // Intense fire
            }
            showNewsAlert("EMERGENCY: Wildfire approaching from neighboring forest! Act quickly!");
          } else if (emergencyType === "drought") {
            emergencyWarning.textContent = "EXTREME DROUGHT!";
            emergencyWarning.style.display = "block";
            droughtEffect.style.opacity = 0.6;
            fireControl -= 30;
            if (fireControl < 0) fireControl = 0;
            updateUI();
            showNewsAlert("EMERGENCY: Extreme drought conditions! Fire danger critical!");
          } else if (emergencyType === "infestation") {
            emergencyWarning.textContent = "BARK BEETLE INFESTATION!";
            emergencyWarning.style.display = "block";
            // Damage random trees
            trees.forEach(tree => {
              if (Math.random() < 0.3) {
                tree.health -= 40;
              }
            });
            forestHealth -= 15;
            if (forestHealth < 0) forestHealth = 0;
            updateUI();
            showNewsAlert("EMERGENCY: Bark beetle infestation detected! Trees weakening rapidly!");
          } else if (emergencyType === "storm") {
            emergencyWarning.textContent = "INCOMING STORM!";
            emergencyWarning.style.display = "block";
            // Increase wind dramatically
            windSpeed = 10;
            windDirection = Math.random() * Math.PI * 2;
            windSpeedEl.textContent = getWindSpeedText(windSpeed);
            windArrow.style.transform = `rotate(${windDirection}rad)`;
            
            // Create occasional lightning strikes
            const stormInterval = setInterval(() => {
              if (Math.random() < 0.3) {
                createLightningStrike();
              }
            }, 2000);
            
            // Clear interval when emergency ends
            setTimeout(() => {
              clearInterval(stormInterval);
            }, 10000);
            
            showNewsAlert("EMERGENCY: Severe thunderstorm approaching! Lightning strikes imminent!");
          }
        }
        
        // Update active emergency
        if (emergencyActive) {
          emergencyTimer--;
          
          // Flash warning text
          if (emergencyTimer % 30 < 15) {
            emergencyWarning.style.color = "#F44336";
          } else {
            emergencyWarning.style.color = "#FFD700";
          }
          
          // End emergency
          if (emergencyTimer <= 0) {
            emergencyActive = false;
            emergencyWarning.style.display = "none";
            
            // Clear emergency effects
            if (emergencyType === "drought") {
              droughtEffect.style.opacity = 0;
              showNewsAlert("Drought emergency has ended. Conditions returning to normal.");
            } else if (emergencyType === "storm") {
              windSpeed = Math.random() * 3;
              windSpeedEl.textContent = getWindSpeedText(windSpeed);
              showNewsAlert("Storm has passed. Wind conditions stabilizing.");
            } else {
              showNewsAlert("Emergency situation contained. Stay vigilant.");
            }
          }
        }
      }
      
      // Update timer
      function updateTimer() {
        // Update timer every second
        const now = Date.now();
        if (now - lastTimerUpdate >= 1000) {
          levelTimeRemaining--;
          const percentRemaining = (levelTimeRemaining / levelTimeLimit) * 100;
          timerFill.style.width = `${percentRemaining}%`;
          
          // Change color based on time remaining
          if (percentRemaining < 20) {
            timerFill.style.backgroundColor = "#F44336"; // Red
          } else if (percentRemaining < 50) {
            timerFill.style.backgroundColor = "#FFC107"; // Yellow
          } else {
            timerFill.style.backgroundColor = "#4CAF50"; // Green
          }
          
          // Warning when time is low
          if (levelTimeRemaining <= 10 && levelTimeRemaining > 0) {
            showNewsAlert(`WARNING: Only ${levelTimeRemaining} seconds remaining!`);
          }
          
          lastTimerUpdate = now;
          
          // Time's up
          if (levelTimeRemaining <= 0) {
            timeUp();
          }
        }
      }
      
      // Time's up function
      function timeUp() {
        // Check if objectives are met
        const objectivesMet = biodiversity >= 80 && trees.length >= 10 + currentLevel;
        
        if (objectivesMet) {
          // Level complete despite time running out
          document.getElementById("treesSaved").textContent = treesSaved;
          document.getElementById("newGrowth").textContent = newGrowth;
          document.getElementById("wildlifeProtected").textContent = wildlife.length;
          
          levelComplete.style.display = "block";
          cancelAnimationFrame(animationFrameId);
        } else {
          // Level failed
          cancelAnimationFrame(animationFrameId);
          alert("Time's up! You failed to complete the objectives in time.");
          resetLevel();
          startLevel();
          gameLoop();
        }
      }

      // Game initialization
      function startGame() {
        resetGame();
        startLevel();
        gameLoop();
      }
      
      function resetGame() {
        currentLevel = 1;
        document.getElementById("levelIndicator").textContent = `Level ${currentLevel}`;
        
        forestHealth = 100;
        fireControl = 100;
        biodiversity = 50;
        
        // Reset time
        levelTimeLimit = 60;
        levelTimeRemaining = levelTimeLimit;
        lastTimerUpdate = Date.now();
        
        // Reset weather
        weatherType = "normal";
        weatherIntensity = 0;
        rainEffect.style.opacity = 0;
        droughtEffect.style.opacity = 0;
        
        // Reset wind
        windSpeed = 0;
        windDirection = 0;
        windSpeedEl.textContent = getWindSpeedText(windSpeed);
        windArrow.style.transform = `rotate(${windDirection}rad)`;
        
        // Reset emergencies
        emergencyActive = false;
        emergencyWarning.style.display = "none";
        
        updateUI();
      }
      
      function resetLevel() {
        // Clear all elements
        trees = [];
        overgrowth = [];
        wildlife = [];
        saplings = [];
        fires = [];
        burnedAreas = [];
        
        // Reset stats
        treesSaved = 0;
        newGrowth = 0;
        wildlifeProtected = 0;
        
        // Reset metrics but make them harder with each level
        forestHealth = 100;
        fireControl = 100;
        biodiversity = 40 + (currentLevel * 5);
        if (biodiversity > 100) biodiversity = 100;
        
        // Reset timer with less time for higher levels
        levelTimeLimit = Math.max(30, 60 - (currentLevel * 5));
        levelTimeRemaining = levelTimeLimit;
        lastTimerUpdate = Date.now();
        
        // Reset weather
        weatherType = "normal";
        weatherIntensity = 0;
        rainEffect.style.opacity = 0;
        droughtEffect.style.opacity = 0;
        
        // Reset wind to be more challenging in higher levels
        windSpeed = Math.min(currentLevel - 1, 5);
        windDirection = Math.random() * Math.PI * 2;
        windSpeedEl.textContent = getWindSpeedText(windSpeed);
        windArrow.style.transform = `rotate(${windDirection}rad)`;
        
        // Reset emergencies
        emergencyActive = false;
        emergencyWarning.style.display = "none";
        emergencyChance = 0.0005 * currentLevel; // Increases with level
        
        updateUI();
      }
      
      function startLevel() {
        // Generate trees
        const treeCount = 15 + (currentLevel * 3);
        for (let i = 0; i < treeCount; i++) {
          trees.push({
            x: Math.random() * (forestCanvas.width - 60) + 30,
            y: Math.random() * (forestCanvas.height - 100) + 70,
            health: 100,
            age: Math.floor(Math.random() * 4) + 1,  // 1-4 age groups
            scale: (Math.random() * 0.5) + 0.8,      // Random size variation
            burning: false
          });
        }
        
        // Generate overgrowth
        const overgrowthCount = 20 + (currentLevel * 5);
        for (let i = 0; i < overgrowthCount; i++) {
          overgrowth.push({
            x: Math.random() * (forestCanvas.width - 80) + 40,
            y: Math.random() * (forestCanvas.height - 80) + 40,
            density: Math.floor(Math.random() * 3) + 1,  // 1-3 density levels
            burning: false
          });
        }
        
        // Generate wildlife
        const wildlifeCount = 5 + currentLevel;
        for (let i = 0; i < wildlifeCount; i++) {
          wildlife.push({
            x: Math.random() * (forestCanvas.width - 60) + 30,
            y: Math.random() * (forestCanvas.height - 60) + 30,
            type: Math.floor(Math.random() * 3),  // Different wildlife types
            moveDirection: Math.random() * Math.PI * 2,
            moveSpeed: Math.random() * 0.5 + 0.2,
            scared: false
          });
        }
        
        // Show level start news
        showNewsAlert(`Level ${currentLevel} started: You have ${levelTimeLimit} seconds to restore forest health!`);
      }
      
      function updateUI() {
        document.getElementById("forestHealth").style.width = `${forestHealth}%`;
        document.getElementById("fireControl").style.width = `${fireControl}%`;
        document.getElementById("biodiversity").style.width = `${biodiversity}%`;
        
        // Change colors based on values
        if (forestHealth < 30) {
          document.getElementById("forestHealth").style.backgroundColor = "#F44336";
        } else if (forestHealth < 60) {
          document.getElementById("forestHealth").style.backgroundColor = "#FFC107";
        } else {
          document.getElementById("forestHealth").style.backgroundColor = "#4CAF50";
        }
        
        if (fireControl < 30) {
          document.getElementById("fireControl").style.backgroundColor = "#F44336";
        } else if (fireControl < 60) {
          document.getElementById("fireControl").style.backgroundColor = "#FFC107";
        } else {
          document.getElementById("fireControl").style.backgroundColor = "#FF9800";
        }
      }
      
      function gameLoop() {
        // Clear canvas
        ctx.clearRect(0, 0, forestCanvas.width, forestCanvas.height);
        
        // Update game state
        updateGameState();
        
        // Update timer
        updateTimer();
        
        // Update weather
        updateWeather();
        
        // Update wind
        updateWind();
        
        // Update emergencies
        updateEmergencies();
        
        // Draw all elements
        drawForest();
        
        // Check win/lose conditions
        checkGameConditions();
        
        // Continue the loop
        animationFrameId = requestAnimationFrame(gameLoop);
      }
      
      function updateGameState() {
        // Update wildlife movement
        wildlife.forEach(animal => {
          // Change direction occasionally
          if (Math.random() < 0.02) {
            animal.moveDirection = Math.random() * Math.PI * 2;
          }
          
          // Move based on direction
          animal.x += Math.cos(animal.moveDirection) * animal.moveSpeed;
          animal.y += Math.sin(animal.moveDirection) * animal.moveSpeed;
          
          // Boundary check
          if (animal.x < 0) animal.x = 0;
          if (animal.x > forestCanvas.width - 30) animal.x = forestCanvas.width - 30;
          if (animal.y < 0) animal.y = 0;
          if (animal.y > forestCanvas.height - 30) animal.y = forestCanvas.height - 30;
          
          // Run away from fire
          fires.forEach(fire => {
            const dx = animal.x - fire.x;
            const dy = animal.y - fire.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < 80) {  // If fire is close
              animal.scared = true;
              
              // Show warning above animal
              const warningEl = document.createElement("div");
              warningEl.classList.add("animal-warning");
              warningEl.textContent = "!";
              warningEl.style.left = `${animal.x + forestCanvas.getBoundingClientRect().left}px`;
              warningEl.style.top = `${animal.y + forestCanvas.getBoundingClientRect().top - 20}px`;
              document.body.appendChild(warningEl);
              
              setTimeout(() => {
                warningEl.remove();
              }, 1000);
              
              // Run in opposite direction
              animal.moveDirection = Math.atan2(dy, dx);
              animal.moveSpeed = 2;
            } else {
              animal.scared = false;
              animal.moveSpeed = Math.random() * 0.5 + 0.2;
            }
          });
        });
        
        // Update fires with wind influence
        for (let i = fires.length - 1; i >= 0; i--) {
          fires[i].ttl--;
          
          // Wind influence on fire duration
          if (weatherType === "drought") {
            fires[i].ttl -= 0.5 * weatherIntensity / 10; // Drought makes fires last longer
          } else if (weatherType === "rain") {
            fires[i].ttl -= 2 * weatherIntensity / 10; // Rain makes fires die faster
          }
          
          if (fires[i].ttl <= 0) {
            // Convert to burned area
            burnedAreas.push({
              x: fires[i].x,
              y: fires[i].y,
              age: 0
            });
            
            fires.splice(i, 1);
          } else {
            // Wind influence on fire spread
            const spreadDistance = 40 + (windSpeed * 4); // Wind increases spread distance
            const windAngleInfluence = 0.6; // How much wind affects spread direction (0-1)
            
            // Check for spread to nearby overgrowth and trees with wind direction influence
            overgrowth.forEach(brush => {
              if (!brush.burning) {
                // Calculate distance with wind direction influence
                const dx = brush.x - fires[i].x;
                const dy = brush.y - fires[i].y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // Calculate angle between fire and brush
                const angle = Math.atan2(dy, dx);
                
                // Calculate angle difference (how aligned with wind direction)
                let angleDiff = Math.abs(normalizeAngle(angle - windDirection));
                if (angleDiff > Math.PI) angleDiff = 2 * Math.PI - angleDiff;
                
                // Increased spread chance in wind direction
                const spreadChance = 0.05 + (windSpeed / 20) * (1 - (angleDiff / Math.PI) * windAngleInfluence);
                
                if (distance < spreadDistance && Math.random() < spreadChance) {
                  // Start burning
                  brush.burning = true;
                  
                  // Create new fire at this location
                  fires.push({
                    x: brush.x,
                    y: brush.y,
                    intensity: fires[i].intensity,
                    ttl: 100
                  });
                  
                  // Reduce fire control for each new spread
                  fireControl -= 0.5;
                  if (fireControl < 0) fireControl = 0;
                  updateUI();
                }
              }
            });
            
            trees.forEach(tree => {
              if (!tree.burning) {
                const dx = tree.x - fires[i].x;
                const dy = tree.y - fires[i].y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // Calculate angle between fire and tree
                const angle = Math.atan2(dy, dx);
                
                // Calculate angle difference (how aligned with wind direction)
                let angleDiff = Math.abs(normalizeAngle(angle - windDirection));
                if (angleDiff > Math.PI) angleDiff = 2 * Math.PI - angleDiff;
                
                // Increased spread chance in wind direction
                const spreadChance = 0.03 + (windSpeed / 30) * (1 - (angleDiff / Math.PI) * windAngleInfluence);
                
                if (distance < spreadDistance && Math.random() < spreadChance) {
                  // Start burning
                  tree.burning = true;
                  
                  // Create new fire at this location
                  fires.push({
                    x: tree.x,
                    y: tree.y,
                    intensity: fires[i].intensity,
                    ttl: 150
                  });
                  
                  // Reduce forestHealth for burning trees
                  forestHealth -= 2;
                  if (forestHealth < 0) forestHealth = 0;
                  updateUI();
                }
              }
            });
          }
        }
        
        // Update burning trees
        for (let i = trees.length - 1; i >= 0; i--) {
          if (trees[i].burning) {
            // Damage based on fire intensity and weather
            let damageRate = 1;
            if (weatherType === "drought") damageRate *= 1.5;
            if (weatherType === "rain") damageRate *= 0.7;
            
            trees[i].health -= damageRate;
            
            if (trees[i].health <= 0) {
              // Tree is destroyed
              burnedAreas.push({
                x: trees[i].x,
                y: trees[i].y,
                age: 0
              });
              
              trees.splice(i, 1);
            }
          }
        }
        
        // Update burning overgrowth
        for (let i = overgrowth.length - 1; i >= 0; i--) {
          if (overgrowth[i].burning) {
            // Burn rate based on weather
            let burnRate = 0.05;
            if (weatherType === "drought") burnRate *= 1.5;
            if (weatherType === "rain") burnRate *= 0.6;
            
            overgrowth[i].density -= burnRate;
            
            if (overgrowth[i].density <= 0) {
              // Overgrowth is cleared
              burnedAreas.push({
                x: overgrowth[i].x,
                y: overgrowth[i].y,
                age: 0
              });
              
              overgrowth.splice(i, 1);
              
              // Increase biodiversity when overgrowth is cleared properly
              biodiversity += 0.5;
              if (biodiversity > 100) biodiversity = 100;
              updateUI();
            }
          }
        }
        
        // Age burned areas and potentially spawn saplings
        for (let i = burnedAreas.length - 1; i >= 0; i--) {
          burnedAreas[i].age++;
          
          // After some time, burned areas can spawn saplings
          if (burnedAreas[i].age > 300 && Math.random() < 0.005) {
            saplings.push({
              x: burnedAreas[i].x + (Math.random() * 20 - 10),
              y: burnedAreas[i].y + (Math.random() * 20 - 10),
              age: 0,
              growth: 0
            });
            
            newGrowth++;
            
            // Remove the burned area
            burnedAreas.splice(i, 1);
          }
          
          // Eventually, burned areas disappear
          if (burnedAreas[i].age > 500) {
            burnedAreas.splice(i, 1);
          }
        }
        
        // Grow saplings into trees
        for (let i = saplings.length - 1; i >= 0; i--) {
          saplings[i].age++;
          
          // Growth rate affected by weather
          let growthRate = 1;
          if (weatherType === "rain") growthRate = 1.5;
          if (weatherType === "drought") growthRate = 0.5;
          
          saplings[i].growth = Math.min(1, (saplings[i].age * growthRate) / 500);
          
          // When fully grown, convert to a tree
          if (saplings[i].growth >= 1) {
            trees.push({
              x: saplings[i].x,
              y: saplings[i].y,
              health: 100,
              age: 1,
              scale: 0.8,
              burning: false
            });
            
            saplings.splice(i, 1);
            treesSaved++;
            
            // Increase forest health for new trees
            forestHealth += 1;
            if (forestHealth > 100) forestHealth = 100;
            updateUI();
          }
        }
        
        // Natural forest health decline - faster with drought or in higher levels
        let healthDeclineRate = 0.01;
        if (weatherType === "drought") healthDeclineRate *= 2;
        healthDeclineRate *= (1 + (currentLevel * 0.2));
        
        forestHealth -= healthDeclineRate;
        if (forestHealth < 0) forestHealth = 0;
        
        // Natural fire control recovery - slower with drought
        let fireControlRecoveryRate = 0.05;
        if (weatherType === "drought") fireControlRecoveryRate *= 0.5;
        if (weatherType === "rain") fireControlRecoveryRate *= 1.5;
        
        fireControl += fireControlRecoveryRate;
        if (fireControl > 100) fireControl = 100;
        
        // Natural biodiversity decline due to overgrowth - faster in higher levels
        let biodiversityDeclineRate = 0.02 * (1 + (currentLevel * 0.1));
        biodiversity -= biodiversityDeclineRate;
        if (biodiversity < 0) biodiversity = 0;
        
        updateUI();
      }
      
      // Normalize angle to 0-2π range
      function normalizeAngle(angle) {
        while (angle < 0) angle += 2 * Math.PI;
        while (angle >= 2 * Math.PI) angle -= 2 * Math.PI;
        return angle;
      }
      
      function drawForest() {
        // Draw background (could be a nice forest floor texture)
        ctx.fillStyle = "#3a6a3a";
        ctx.fillRect(0, 0, forestCanvas.width, forestCanvas.height);
        
        // Draw burned areas
        burnedAreas.forEach(area => {
          const alpha = Math.max(0, 1 - (area.age / 500));
          ctx.fillStyle = `rgba(80, 60, 40, ${alpha})`;
          ctx.beginPath();
          ctx.ellipse(area.x, area.y, 20, 15, 0, 0, Math.PI * 2);
          ctx.fill();
        });
        
        // Draw overgrowth
        overgrowth.forEach(brush => {
          if (brush.burning) {
            ctx.fillStyle = `rgba(139, 69, 19, ${brush.density / 3})`;
          } else {
            ctx.fillStyle = `rgba(34, 139, 34, ${brush.density / 3})`;
          }
          ctx.beginPath();
          ctx.ellipse(brush.x, brush.y, 30, 15, 0, 0, Math.PI * 2);
          ctx.fill();
        });
        
        // Draw saplings
        saplings.forEach(sapling => {
          ctx.fillStyle = `rgba(60, 179, 113, ${sapling.growth})`;
          ctx.beginPath();
          ctx.rect(sapling.x - 2, sapling.y - 10 * sapling.growth, 4, 10 * sapling.growth);
          ctx.fill();
          
          ctx.beginPath();
          ctx.arc(sapling.x, sapling.y - 10 * sapling.growth, 5 * sapling.growth, 0, Math.PI * 2);
          ctx.fill();
        });
        
        // Draw trees
        trees.forEach(tree => {
          // Tree trunk
          ctx.fillStyle = tree.burning ? "#8B4513" : "#654321";
          ctx.beginPath();
          ctx.rect(tree.x - 3 * tree.scale, tree.y - 20 * tree.scale, 6 * tree.scale, 20 * tree.scale);
          ctx.fill();
          
          // Tree foliage
          if (tree.burning) {
            ctx.fillStyle = `rgba(205, 133, 63, ${tree.health / 100})`;
          } else {
            ctx.fillStyle = "#2E8B57";
          }
          ctx.beginPath();
          ctx.arc(tree.x, tree.y - 25 * tree.scale, 15 * tree.scale, 0, Math.PI * 2);
          ctx.fill();
          
          // Add some detail to trees based on age
          if (tree.age > 1 && !tree.burning) {
            ctx.fillStyle = "#3CB371";
            for (let i = 0; i < tree.age; i++) {
              const angle = (i / tree.age) * Math.PI * 2;
              const distance = 10 * tree.scale;
              const x = tree.x + Math.cos(angle) * distance;
              const y = tree.y - 25 * tree.scale + Math.sin(angle) * distance;
              
              ctx.beginPath();
              ctx.arc(x, y, 5 * tree.scale, 0, Math.PI * 2);
              ctx.fill();
            }
          }
          
          // Show health bar for damaged trees
          if (tree.health < 100 && !tree.burning) {
            const barWidth = 20 * tree.scale;
            const barHeight = 3 * tree.scale;
            
            // Bar background
            ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
            ctx.fillRect(tree.x - barWidth/2, tree.y - 45 * tree.scale, barWidth, barHeight);
            
            // Health fill
            ctx.fillStyle = tree.health > 50 ? "#4CAF50" : "#F44336";
            ctx.fillRect(tree.x - barWidth/2, tree.y - 45 * tree.scale, barWidth * (tree.health/100), barHeight);
          }
        });
        
        // Draw wildlife
        wildlife.forEach(animal => {
          ctx.fillStyle = animal.scared ? "#FFD700" : "#8B4513";
          ctx.beginPath();
          ctx.arc(animal.x, animal.y, 10, 0, Math.PI * 2);
          ctx.fill();
          
          // Draw eyes
          ctx.fillStyle = "#000";
          ctx.beginPath();
          ctx.arc(animal.x + 3, animal.y - 2, 2, 0, Math.PI * 2);
          ctx.fill();
          
          // Draw direction indicator
          const dirX = animal.x + Math.cos(animal.moveDirection) * 8;
          const dirY = animal.y + Math.sin(animal.moveDirection) * 8;
          ctx.beginPath();
          ctx.moveTo(animal.x, animal.y);
          ctx.lineTo(dirX, dirY);
          ctx.strokeStyle = "#000";
          ctx.stroke();
        });
        
        // Draw active fires
        fires.forEach(fire => {
          // Fire base
          const gradient = ctx.createRadialGradient(
            fire.x, fire.y, 0,
            fire.x, fire.y, 20
          );
          gradient.addColorStop(0, "rgba(255, 165, 0, 0.8)");
          gradient.addColorStop(0.5, "rgba(255, 69, 0, 0.6)");
          gradient.addColorStop(1, "rgba(255, 0, 0, 0)");
          
          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.arc(fire.x, fire.y, 20, 0, Math.PI * 2);
          ctx.fill();
          
          // Increase fire size based on intensity
          const baseSize = fire.intensity || 1;
          
          // Flames that respond to wind direction
          for (let i = 0; i < 5; i++) {
            // Influence flame direction by wind
            const windInfluence = windSpeed * 0.5;
            const flameHeight = (10 + Math.sin(Date.now() / 100 + i) * 5) * baseSize;
            const flameWidth = (4 + Math.sin(Date.now() / 150 + i) * 2) * baseSize;
            
            // Calculate flame position with wind influence
            const windOffsetX = Math.cos(windDirection) * windInfluence;
            const windOffsetY = Math.sin(windDirection) * windInfluence;
            
            ctx.fillStyle = i % 2 === 0 ? "rgba(255, 165, 0, 0.7)" : "rgba(255, 69, 0, 0.7)";
            ctx.beginPath();
            ctx.ellipse(
              fire.x + (i - 2) * 5 + windOffsetX * 2, 
              fire.y - flameHeight / 2 + windOffsetY * 2, 
              flameWidth, flameHeight, 
              windDirection, 0, Math.PI * 2
            );
            ctx.fill();
          }
        });
      }
      
      function checkGameConditions() {
        // Check if level is lost (forest health too low)
        if (forestHealth <= 0) {
          cancelAnimationFrame(animationFrameId);
          alert("The forest has been destroyed! Game over.");
          resetGame();
          startLevel();
          gameLoop();
          return;
        }
        
        // Check if level is won (biodiversity high enough with enough trees)
        if (biodiversity >= 80 && trees.length >= 10 + currentLevel) {
          // Level complete!
          document.getElementById("treesSaved").textContent = treesSaved;
          document.getElementById("newGrowth").textContent = newGrowth;
          document.getElementById("wildlifeProtected").textContent = wildlife.length;
          
          levelComplete.style.display = "block";
          cancelAnimationFrame(animationFrameId);
        }
      }

      // Spawn smoke function
      function spawnSmoke(x, y) {
        const smoke = document.createElement("div");
        smoke.classList.add("smoke");
        smoke.style.left = `${x - 10}px`;
        smoke.style.top = `${y - 10}px`;

        document.getElementById("app").appendChild(smoke);

        setTimeout(() => {
          smoke.style.transform = "translateY(-30px) scale(1.5)";
          smoke.style.opacity = "0";
        }, 10);

        setTimeout(() => {
          smoke.remove();
        }, 1000);
      }
      
      // Create fire at cursor position with optional intensity
      function createFire(x, y, intensity = 1) {
        if (fireControl <= 10 && !emergencyActive) return; // Can't create fire if control is too low, except during emergencies
        
        fires.push({
          x: x,
          y: y,
          intensity: intensity,
          ttl: 150 * intensity
        });
        
        // Create fire particles
        for (let i = 0; i < 8 * intensity; i++) {
          const particleAngle = Math.random() * Math.PI * 2;
          const particleDistance = Math.random() * 20 * intensity;
          
          const particle = document.createElement("div");
          particle.classList.add("fire-particle");
          particle.style.left = `${x + Math.cos(particleAngle) * particleDistance}px`;
          particle.style.top = `${y + Math.sin(particleAngle) * particleDistance}px`;
          
          document.getElementById("app").appendChild(particle);
          
          // Animation
          let lifespan = 0;
          const maxLife = 30 + Math.random() * 20;
          
          // Wind influences particle movement
          const windInfluence = windSpeed * 0.2;
          const moveX = Math.cos(particleAngle) * (1 + Math.random() * 2) + Math.cos(windDirection) * windInfluence;
          const moveY = Math.sin(particleAngle - Math.PI/2) * (2 + Math.random() * 2) + Math.sin(windDirection) * windInfluence;
          
          const animate = () => {
            lifespan++;
            
            const currentX = parseFloat(particle.style.left);
            const currentY = parseFloat(particle.style.top);
            
            particle.style.left = `${currentX + moveX}px`;
            particle.style.top = `${currentY + moveY}px`;
            
            if (lifespan < maxLife) {
              requestAnimationFrame(animate);
            } else {
              particle.remove();
            }
          };
          
          requestAnimationFrame(animate);
        }
        
        // Reduce fire control (more for higher intensity)
        fireControl -= 5 * intensity;
        if (fireControl < 0) fireControl = 0;
        updateUI();
        
        // Screen shake for high intensity fires
        if (intensity >= 2) {
          document.getElementById("gameContainer").classList.add("screen-shake");
          setTimeout(() => {
            document.getElementById("gameContainer").classList.remove("screen-shake");
          }, 500);
        }
      }

      // Random news alerts
      function showRandomNews() {
        newsTimer++;
        
        if (newsTimer > 900 && Math.random() < 0.01) { // ~15 seconds between messages
          const randomMessage = newsMessages[Math.floor(Math.random() * newsMessages.length)];
          showNewsAlert(randomMessage);
          newsTimer = 0;
        }
      }

      // Mouse events
      document.body.addEventListener("mousedown", function (e) {
        if (gameScreen.classList.contains("active")) {
          isDrawing = true;
          customCursor.style.transform = "scale(1.2)";
          
          const rect = forestCanvas.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;
          
          if (x >= 0 && x <= forestCanvas.width && y >= 0 && y <= forestCanvas.height) {
            createFire(x, y);
          }
        } else {
          isDrawing = true;
          customCursor.style.transform = "scale(1.2)";
        }
      });

      document.body.addEventListener("mouseup", function (e) {
        isDrawing = false;
        customCursor.style.transform = "scale(1)";
      });

      document.body.addEventListener("mousemove", function (e) {
        customCursor.style.left = `${e.pageX - 20}px`;
        customCursor.style.top = `${e.pageY - 20}px`;
        customCursor.style.display = "block";

        if (isDrawing && gameScreen.classList.contains("active")) {
          const now = Date.now();
          // Faster smoke generation during drought
          const smokeInterval = weatherType === "drought" ? 30 : 50;
          
          if (now - lastSmokeTime > smokeInterval) {
            spawnSmoke(e.pageX, e.pageY);
            lastSmokeTime = now;
            
            const rect = forestCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            if (x >= 0 && x <= forestCanvas.width && y >= 0 && y <= forestCanvas.height) {
              createFire(x, y);
            }
          }
        } else if (isDrawing) {
          const now = Date.now();
          if (now - lastSmokeTime > 50) {
            spawnSmoke(e.pageX, e.pageY);
            lastSmokeTime = now;
          }
        }
      });
    });
  </script>

  
</body>
</html>




















